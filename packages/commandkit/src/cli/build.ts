// @ts-check

import { readFile, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { build } from 'tsup';
import {
  copyLocaleFiles,
  erase,
  findCommandKitConfig,
  panic,
  write,
} from './common.js';
import colors from '../utils/colors.js';
import { createSpinner } from './utils';
import { BuildOptions } from './types';
import { CompilerPluginRuntime } from '../plugins/runtime/CompilerPluginRuntime.js';
import { isCompilerPlugin } from '../plugins/CompilerPlugin.js';

export async function bootstrapProductionBuild(configPath: string) {
  const config = await findCommandKitConfig(configPath);
  const spinner = await createSpinner('Creating optimized production build...');
  const start = performance.now();

  try {
    await buildProject(config);
    spinner.succeed(
      colors.green(
        `Build completed in ${(performance.now() - start).toFixed(2)}ms!`,
      ),
    );
  } catch (e) {
    spinner.fail('Build failed');
    panic(e instanceof Error ? e.stack : e);
  }
}

export async function bootstrapDevelopmentBuild(configPath: string) {
  const config = await findCommandKitConfig(configPath);

  try {
    await buildProject({
      ...config,
      outDir: '.commandkit',
      isDevelopment: true,
    });
  } catch (e) {
    console.error(e instanceof Error ? e.stack : e);
    console.error(
      colors.red('Failed to build the project. Waiting for changes...'),
    );
  }
}

async function buildProject(options: BuildOptions) {
  const {
    sourcemap = false,
    minify = false,
    outDir = 'dist',
    antiCrash = true,
    main,
    requirePolyfill: polyfillRequire,
  } = options;

  const config = await findCommandKitConfig(process.cwd());

  erase(outDir);

  const compilerPlugins = config.plugins.filter((p) => !isCompilerPlugin(p));

  try {
    await build({
      clean: true,
      format: ['esm'],
      dts: false,
      skipNodeModulesBundle: true,
      minify,
      shims: true,
      banner: options.isDevelopment
        ? {}
        : {
            js: '/* Optimized production build generated by CommandKit */',
          },
      sourcemap,
      keepNames: true,
      outDir,
      silent: true,
      watch: !!options.isDevelopment && !!options.watch,
      cjsInterop: true,
      splitting: true,
      entry: ['src', '!dist', '!.commandkit', `!${outDir}`],
      esbuildPlugins: [
        // @ts-ignore
        new CompilerPluginRuntime(compilerPlugins),
      ],
      jsxFactory: 'CommandKit.createElement',
      jsxFragment: 'CommandKit.Fragment',
      async onSuccess() {
        await copyLocaleFiles('src', outDir);
      },
    });

    await injectShims(
      outDir,
      main,
      !options.isDevelopment && antiCrash,
      !!polyfillRequire,
    );

    if (!options.isDevelopment) {
      write(
        colors.green(
          `\nRun ${colors.magenta(`commandkit start`)} ${colors.green(
            'to start your bot.',
          )}`,
        ),
      );
    }
  } catch (e) {
    panic(e);
  }
}

export async function injectShims(
  outDir: string,
  main: string,
  antiCrash: boolean,
  polyfillRequire: boolean,
) {
  const path = join(process.cwd(), outDir, main);

  const head = ['\n\n;await (async()=>{', "  'use strict';"].join('\n');
  const tail = '\n})();';
  const requireScript = polyfillRequire
    ? [
        '// --- CommandKit require() polyfill ---',
        '  if (typeof require === "undefined") {',
        '    const { createRequire } = await import("node:module");',
        '    const __require = createRequire(import.meta.url);',
        '    Object.defineProperty(globalThis, "require", {',
        '      value: (id) => {',
        '        return __require(id);',
        '      },',
        '      configurable: true,',
        '      enumerable: false,',
        '      writable: true,',
        '    });',
        '  }',
        '// --- CommandKit require() polyfill ---',
      ].join('\n')
    : '';

  const antiCrashScript = antiCrash
    ? [
        '// --- CommandKit Anti-Crash Monitor ---',
        "  // 'uncaughtException' event is supposed to be used to perform synchronous cleanup before shutting down the process",
        '  // instead of using it as a means to resume operation.',
        '  // But it exists here due to compatibility reasons with discord bot ecosystem.',
        "  const p = (t) => `\\x1b[33m${t}\\x1b[0m`, b = '[CommandKit Anti-Crash Monitor]', l = console.log, e1 = 'uncaughtException', e2 = 'unhandledRejection';",
        '  if (!process.eventNames().includes(e1)) // skip if it is already handled',
        '    process.on(e1, (e) => {',
        '      l(p(`${b} Uncaught Exception`)); l(p(b), p(e.stack || e));',
        '    })',
        '  if (!process.eventNames().includes(e2)) // skip if it is already handled',
        '    process.on(e2, (r) => {',
        '      l(p(`${b} Unhandled promise rejection`)); l(p(`${b} ${r.stack || r}`));',
        '    });',
        '// --- CommandKit Anti-Crash Monitor ---',
      ].join('\n')
    : '';

  const contents = await readFile(path, 'utf-8');
  const finalScript = [
    head,
    requireScript,
    antiCrashScript,
    tail,
    '\n\n',
    contents,
  ].join('\n');

  return writeFile(path, finalScript);
}
